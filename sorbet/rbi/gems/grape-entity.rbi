# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/grape-entity/all/grape-entity.rbi
#
# grape-entity-0.10.2

module GrapeEntity
end
module Grape
end
class Grape::Entity
  def as_json(runtime_options = nil); end
  def delegate_attribute(attribute); end
  def delegator; end
  def documentation; end
  def exec_with_attribute(attribute, &block); end
  def exec_with_object(options, &block); end
  def formatters; end
  def initialize(object, options = nil); end
  def inspect; end
  def is_defined_in_entity?(attribute); end
  def object; end
  def options; end
  def presented; end
  def root_exposure; end
  def root_exposures; end
  def self.build_exposure_for_attribute(attribute, nesting_stack, options, block); end
  def self.can_unexpose?; end
  def self.cannot_unexpose!; end
  def self.delegation_opts; end
  def self.documentation; end
  def self.expose(*args, &block); end
  def self.find_exposure(attribute); end
  def self.format_with(name, &block); end
  def self.formatters; end
  def self.formatters=(arg0); end
  def self.hash_access; end
  def self.hash_access=(value); end
  def self.inherited(subclass); end
  def self.merge_options(options); end
  def self.present_collection(present_collection = nil, collection_name = nil); end
  def self.represent(objects, options = nil); end
  def self.root(plural, singular = nil); end
  def self.root_element(root_type); end
  def self.root_exposure; end
  def self.root_exposure=(arg0); end
  def self.root_exposures; end
  def self.unexpose(*attributes); end
  def self.unexpose_all; end
  def self.valid_options(options); end
  def self.with_options(options); end
  def serializable_hash(runtime_options = nil); end
  def to_json(options = nil); end
  def to_xml(options = nil); end
  def value_for(key, options = nil); end
end
module Grape::Entity::DSL
  def entity(options = nil); end
  def self.included(base); end
end
module Grape::Entity::DSL::ClassMethods
  def entity(*exposures, &block); end
  def entity_class(search_ancestors = nil); end
end
module Grape::Entity::Delegator
  def self.new(object); end
end
class Grape::Entity::Delegator::Base
  def accepts_options?; end
  def delegatable?(_attribute); end
  def initialize(object); end
  def object; end
end
class Grape::Entity::Delegator::HashObject < Grape::Entity::Delegator::Base
  def delegate(attribute, hash_access: nil); end
end
class Grape::Entity::Delegator::OpenStructObject < Grape::Entity::Delegator::Base
  def delegate(attribute); end
end
class Grape::Entity::Delegator::FetchableObject < Grape::Entity::Delegator::Base
  def delegate(attribute); end
end
class Grape::Entity::Delegator::PlainObject < Grape::Entity::Delegator::Base
  def delegatable?(attribute); end
  def delegate(attribute); end
end
module Grape::Entity::Exposure
  def self.build_block_exposure(base_args, passed_proc); end
  def self.build_class_exposure(base_args, using_class, passed_proc); end
  def self.build_delegator_exposure(base_args); end
  def self.build_formatter_exposure(base_args, format_with); end
  def self.build_nesting_exposure(base_args); end
  def self.compile_conditions(attribute, options); end
  def self.expose_nil_condition(attribute, options); end
  def self.new(attribute, options); end
end
class Grape::Entity::Exposure::Base
  def ==(other); end
  def attr_path(entity, options); end
  def attribute; end
  def conditional?; end
  def conditions; end
  def conditions_met?(entity, options); end
  def deep_complex_nesting?(entity); end
  def documentation; end
  def dup(&block); end
  def dup_args; end
  def for_merge; end
  def initialize(attribute, options, conditions); end
  def is_safe; end
  def key(entity = nil); end
  def nesting?; end
  def options; end
  def override; end
  def override?; end
  def self.new(attribute, options, conditions, *args, &block); end
  def serializable_value(entity, options); end
  def setup; end
  def should_expose?(entity, options); end
  def should_return_key?(options); end
  def valid?(entity); end
  def valid_value(entity, options); end
  def value(_entity, _options); end
  def with_attr_path(entity, options, &block); end
end
class Grape::Entity::Exposure::RepresentExposure < Grape::Entity::Exposure::Base
  def ==(other); end
  def dup_args; end
  def setup(using_class_name, subexposure); end
  def subexposure; end
  def using_class; end
  def using_class_name; end
  def using_options_for(options); end
  def valid?(entity); end
  def value(entity, options); end
end
class Grape::Entity::Exposure::BlockExposure < Grape::Entity::Exposure::Base
  def ==(other); end
  def block; end
  def dup; end
  def setup(&block); end
  def valid?(_entity); end
  def value(entity, options); end
end
class Grape::Entity::Exposure::DelegatorExposure < Grape::Entity::Exposure::Base
  def value(entity, _options); end
end
class Grape::Entity::Exposure::FormatterExposure < Grape::Entity::Exposure::Base
  def ==(other); end
  def dup_args; end
  def format_with; end
  def setup(format_with); end
  def value(entity, _options); end
end
class Grape::Entity::Exposure::FormatterBlockExposure < Grape::Entity::Exposure::Base
  def ==(other); end
  def dup; end
  def format_with; end
  def setup(&format_with); end
  def value(entity, _options); end
end
class Grape::Entity::Exposure::NestingExposure < Grape::Entity::Exposure::Base
  def ==(other); end
  def deep_complex_nesting?(entity); end
  def dup_args; end
  def easy_normalized_exposures(entity, options); end
  def find_nested_exposure(attribute); end
  def map_entity_exposures(entity, options); end
  def nested_exposures; end
  def nesting?; end
  def nesting_options_for(options); end
  def normalized_exposures(entity, options); end
  def serializable_value(entity, options); end
  def setup(nested_exposures = nil); end
  def valid?(entity); end
  def valid_value_for(key, entity, options); end
  def value(entity, options); end
end
class Grape::Entity::Exposure::NestingExposure::NestedExposures
  def <<(exposure); end
  def ==(*args, &block); end
  def [](*args, &block); end
  def all?(*args, &block); end
  def clear; end
  def count(*args, &block); end
  def deep_complex_nesting?(entity); end
  def delete_by(*attributes); end
  def each(*args, &block); end
  def each_with_object(*args, &block); end
  def empty?(*args, &block); end
  def find_by(attribute); end
  def initialize(exposures); end
  def length(*args, &block); end
  def reset_memoization!; end
  def select(*args, &block); end
  def select_by(attribute); end
  def size(*args, &block); end
  def to_a(*args, &block); end
  def to_ary(*args, &block); end
  include Enumerable
end
class Grape::Entity::Exposure::NestingExposure::OutputBuilder < SimpleDelegator
  def __getobj__; end
  def add(exposure, result); end
  def initialize(entity); end
  def is_a?(klass); end
  def kind_of?(klass); end
  def merge_strategy(for_merge); end
  def output; end
end
module Grape::Entity::Condition
  def self.condition(inverse, arg); end
  def self.new_if(arg); end
  def self.new_unless(arg); end
end
class Grape::Entity::Condition::Base
  def ==(other); end
  def if_value(_entity, _options); end
  def initialize(inverse = nil); end
  def inversed?; end
  def met?(entity, options); end
  def self.new(inverse, *args, &block); end
  def unless_value(entity, options); end
end
class Grape::Entity::Condition::BlockCondition < Grape::Entity::Condition::Base
  def ==(other); end
  def block; end
  def if_value(entity, options); end
  def setup(block); end
end
class Grape::Entity::Condition::HashCondition < Grape::Entity::Condition::Base
  def ==(other); end
  def cond_hash; end
  def if_value(_entity, options); end
  def setup(cond_hash); end
  def unless_value(_entity, options); end
end
class Grape::Entity::Condition::SymbolCondition < Grape::Entity::Condition::Base
  def ==(other); end
  def if_value(_entity, options); end
  def setup(symbol); end
  def symbol; end
end
class Grape::Entity::Options
  def ==(other); end
  def [](*args, &block); end
  def build_for_nesting(key); end
  def build_symbolized_hash(attribute, hash); end
  def dig(*args, &block); end
  def empty?(*args, &block); end
  def except_fields(for_key = nil); end
  def fetch(*args, &block); end
  def for_nesting(key); end
  def initialize(opts_hash = nil); end
  def key?(*args, &block); end
  def merge(new_opts); end
  def only_fields(for_key = nil); end
  def only_for_given(key, fields); end
  def opts_hash; end
  def reverse_merge(new_opts); end
  def should_return_key?(key); end
  def with_attr_path(part); end
  extend Forwardable
end
class Grape::Entity::Deprecated < StandardError
  def initialize(msg, spec); end
end
